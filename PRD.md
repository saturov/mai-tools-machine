# PRD: Отображение статусов этапов работы CLI-скрипта

## 1. Цель

Обеспечить наглядное, компактное и предсказуемое отображение статусов выполнения этапов скрипта в терминале с динамической перерисовкой строк без засорения вывода.

Интерфейс должен:
- Обновлять статусы в той же строке.
- Использовать эмодзи для статусов.
- Использовать цветовую индикацию в цепочке шагов workflow.
- Не выводить блок `[Summary]`.

## 2. Контекст и текущая проблема

Текущий `pretty`-вывод основан на формате:
`[Этап] [STATE] key=value | summary`.

Проблемы текущего формата:
- Каждое обновление добавляет новую строку.
- Шумный вывод для длинных сценариев.
- Есть служебный блок `[Summary]`, который не нужен в UX.
- Нет стабильного фиксированного layout в терминале.

## 3. Статусы этапа

Каждый этап отображается с эмодзи-индикатором:
- В процессе: `⏳`
- Успех: `✅`
- Ошибка: `❌`

Эмодзи обновляется в той же строке при смене статуса.

## 4. Общая структура вывода

Этапы выводятся строго в следующем порядке:
1. Планирование запроса
2. Проверка покрытия
3. Проверка политик
4. Выполнение задачи
5. Финальный статус

Правила:
- Каждый этап занимает свою фиксированную строку.
- При смене статуса строка перерисовывается, новая строка не добавляется.
- Для этапа `Выполнение задачи` дополнительно есть отдельная строка цепочки workflow.

## 5. Детализация этапов

### 5.1 Планирование запроса

Формат строки:
`Планирование запроса {эмодзи}`

### 5.2 Проверка покрытия

Формат строки:
`Проверка покрытия {эмодзи}`

Если этап завершился ошибкой:
- На следующей строке выводится красным:
`Реализуйте утилиты: {названия нереализованных утилит через запятую}`
- Эта строка не перерисовывается.
- После вывода ошибки выполнение останавливается.

### 5.3 Проверка политик

Формат строки:
`Проверка политик {эмодзи}`

Дополнительные строки не выводятся.

### 5.4 Выполнение задачи

Основная строка:
`Выполнение задачи {эмодзи}`

Следующая строка:
`youtube.download  ->  drive.upload`

Правила отображения цепочки:
- Текущий выполняющийся этап: жёлтый.
- Упавший этап: красный.
- Завершённые этапы: зелёный.
- Цепочка всегда перерисовывается в одной строке.
- При переходе к следующему этапу строка перерисовывается полностью.
- При ошибке цепочка перерисовывается с красным выделением упавшего этапа.
- Запрещено добавлять новые строки на каждом шаге.

### 5.5 Финальный статус

Если задача выполнена успешно:
`Задача выполнена ✅`

Если задача завершилась ошибкой:
`Задача не выполнена ❌`
`{человекочитаемое описание ошибки}`

Требования к описанию ошибки:
- Выводится на следующей строке.
- Понятно без чтения stack trace.
- Без технического шума.

## 6. Ограничения рендеринга

1. Все обновления в TTY-режиме идут через перерисовку строк (ANSI cursor control).
2. Новые строки допускаются только:
- При выводе ошибки покрытия.
- При выводе финальной ошибки.
3. Блок `[Summary]` никогда не выводится.
4. Вывод корректно работает в стандартном TTY-терминале.
5. Для non-TTY (redirect в файл/CI лог) допускается деградация в последовательный вывод без перерисовки.

## 7. Нефункциональные требования

- Минимальный шум в stdout.
- Предсказуемый порядок строк.
- Отсутствие мерцания и "скачков" курсора.
- Безопасная деградация без ANSI в non-TTY.
- Сохранение существующего JSON-поведения и exit-кодов.

## 8. Технический дизайн реализации

### 8.1 Архитектурный подход

Вынести рендеринг в отдельный слой с двумя реализациями:
- `TTYRenderer`: фиксированный буфер строк + адресная перерисовка.
- `PlainRenderer`: линейный вывод без ANSI.

Обе реализации работают через единый интерфейс, например:
- `start(stages:, chain:)`
- `update_stage(name:, state:)`
- `update_chain(steps:, current_index:, failed_index:)`
- `emit_coverage_error(missing_caps:)`
- `emit_final(success:, message: nil)`
- `flush`

### 8.2 Маппинг событий агента в UI

- `Планирование запроса`
  - start: `⏳`
  - success: `✅`
  - fail: `❌`
- `Проверка покрытия`
  - start: `⏳`
  - complete/full: `✅`
  - gap: `❌` + `Реализуйте утилиты: ...` и stop
- `Проверка политик`
  - start: `⏳`
  - allow: `✅`
  - deny: `❌`
- `Выполнение задачи`
  - start: `⏳`
  - step events обновляют строку цепочки
  - workflow fail: `❌`
  - workflow success: `✅`
- `Финальный статус`
  - success: `Задача выполнена ✅`
  - failure: `Задача не выполнена ❌` + human-readable причина

### 8.3 ANSI и цветовая схема

Цвета для цепочки workflow:
- active: жёлтый (`\e[33m...\e[0m`)
- failed: красный (`\e[31m...\e[0m`)
- completed: зелёный (`\e[32m...\e[0m`)
- pending: базовый цвет

Рекомендация: централизовать escape-коды в одном модуле форматирования.

### 8.4 Изменения в коде (точки внедрения)

Основной файл:
- `scripts/agent.rb`

План изменений:
1. Заменить текущий `StageReporter` на рендерер с поддержкой redraw.
2. Удалить генерацию и вывод этапа `Summary`.
3. Привести названия этапов к PRD:
- `Проверка покрытия capability` -> `Проверка покрытия`
- `Выполнение workflow` -> `Выполнение задачи`
- `Итог выполнения` -> `Финальный статус`
4. Перепривязать `event_handler` workflow к `update_chain`.
5. Убрать служебный pretty-блок `[Ошибка] [FAIL]` из stdout; технические детали остаются в JSON payload.
6. Сохранить текущие exit-коды и структуру machine-readable JSON.

### 8.5 Логика деградации для non-TTY

Условия перехода в `PlainRenderer`:
- `!$stdout.tty?` или
- явный запрет ANSI через env (`NO_COLOR` и/или отдельный флаг в будущем).

Поведение:
- Без cursor move.
- Линейные строки в том же порядке этапов.
- Семантика статусов и финальных сообщений сохраняется.

## 9. План реализации (декомпозиция задач)

### T1. Контракт рендера и state-модель

Результат:
- Спецификация интерфейса рендера и таблица переходов состояний.

DoD:
- Зафиксированы все переходы `RUNNING/OK/FAIL`.
- Зафиксировано поведение в coverage-fail и workflow-fail.

### T2. Реализация `TTYRenderer`

Результат:
- Фиксированный layout строк.
- Адресная перерисовка строк ANSI-управлением курсора.

DoD:
- При апдейтах число строк не растет.
- Корректный redraw на длинных цепочках шагов.

### T3. Реализация `PlainRenderer`

Результат:
- Линейный fallback-вывод для non-TTY.

DoD:
- Вывод читаемый и полный в redirected logs.

### T4. Интеграция в `scripts/agent.rb`

Результат:
- Этапы агента переведены на новый рендерер.
- `Summary` удален.

DoD:
- Порядок этапов строго по PRD.
- Финальный статус всегда печатается.

### T5. Рендер цепочки workflow

Результат:
- Отрисовка chain line из событий `step_attempt_started/step_succeeded/step_failed/step_retry`.

DoD:
- active жёлтый, failed красный, completed зелёный.
- Цепочка всегда перерисовывается в одной строке.

### T6. Финальные ошибки и human-readable сообщения

Результат:
- Унифицированное человекочитаемое описание ошибок для финальной строки.

DoD:
- Без stack trace в pretty-выводе.
- Достаточно контекста для действий пользователя.

### T7. Тесты

Результат:
- Обновленные/новые тесты `scripts/agent_test.rb`.

DoD:
- Проверки отсутствия `[Summary]`.
- Проверки эмодзи-статусов.
- Проверки цветового контракта chain.
- Проверки fallback non-TTY.

### T8. Документация

Результат:
- Обновлены `REQUEST_SAMPLES.md`, `docs/skills-ecosystem-architecture.md`.
- Добавлен ADR о переходе на PRD-формат терминального статуса.

DoD:
- Примеры команд и выводов соответствуют фактическому поведению.

## 10. Критерии приемки

1. В `pretty`+TTY режиме этапы отображаются и перерисовываются без роста количества строк.
2. В цепочке workflow соблюдены цвета:
- active жёлтый
- failed красный
- completed зелёный
3. Блок `[Summary]` отсутствует во всех успешных и ошибочных сценариях.
4. При gap coverage печатается:
`Реализуйте утилиты: ...`
и выполнение останавливается.
5. При финальной ошибке печатается:
`Задача не выполнена ❌`
и понятная причина на следующей строке.
6. В non-TTY режиме вывод остается читаемым и не содержит ANSI-перерисовки.

## 11. Риски и меры

- Риск: ломка существующих тестов на старый pretty-формат.
  - Мера: обновить тестовые ожидания и добавить контрактные тесты рендера.
- Риск: артефакты курсора в некоторых терминалах.
  - Мера: использовать минимальный набор ANSI-команд и покрыть smoke-тестами.
- Риск: расхождение docs и runtime.
  - Мера: обновлять ADR и примеры вывода в той же задаче.

## 12. UX-принципы

- Никакого лишнего вывода.
- Всегда виден текущий этап.
- Ошибка визуально выделена.
- Финальный статус однозначен.
- Нет дублирования информации.
